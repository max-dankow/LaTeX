\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{xcolor}

\begin{document}
\tableofcontents
\newpage

\section{Детерминированные протоколы}
\subsection{Модель вычислений и основные определения}


\newtheorem{Def}{Определение}
\newtheorem{Statement}{Утверждение}
\newtheorem{Th}{Теорема}

Будем рассматривать следующую задачу.
Есть два участника процесса(два человека или два компьютера), которые должны совместно вычислить значение функции
$ f \colon X \times Y \rightarrow Z $, где $X, Y, Z$ некоторые конечные множества.
В качестве $Z$ обычно будем рассматривать множество значений бита \{0, 1\}.
Традиционно этих участников называют Алиса и Боб,
поэтому для удобства и соответствия литературе будем называть их так же.
Сложность их задачи состоит в том, что аргумент, на котором необходимо посчитать значение функции, разделен на две части:
у Алисы есть только $x \in X$, а у Боба только $y \in Y$.

Однако в их распоряжении есть некий абстрактный канал связи, через который они могут передавать друг другу данные. Передача по этому каналу связи может быть дорогой(или занимать значительное время), поэтому необходимо минимизировать количество битов, передаваемых в процессе вычисления функции.

Так же предполагается, что Алиса и Боб заранее знают функцию $f$ и договариваются о протоколе -
наборе соглашений о том, как и в каком порядке будет происходить обмен информацией. В коммуникационной сложности учитывается только количество передаваемых битов, а время вычислений у каждого участника игнорируется.

\begin{Def}
Коммуникационным протоколом для вычисления некоторой функции
$ f \colon X \times Y \rightarrow Z $
называется ориентированное двоичное дерево, такое что:
\begin{enumerate}
    \item
    Каждой \textbf{листовой} вершине ставится в соответствие некоторый элемент из Z.
    \item
    Каждая \textbf{внутренняя} вершина помечена значением из $ \{ A, B \} $
    \item
    Для для каждой вершины $v_i$ с пометкой $A$ задана функция \linebreak
    $ g_i \colon X \rightarrow \{0, 1\} $
    \item
    Для для каждой вершины $v_j$ с пометкой $B$ задана функция \linebreak
    $ h_j \colon Y \rightarrow \{0, 1\} $
    \item
    Каждому ребру приписано значение из \{0, 1\}, а из каждой вершины, не являющегося листом, исходит ровно одно ребро с пометкой 0 и ровно одно с пометкой 1.
\end{enumerate}
\end{Def}

Выполнение протокола участниками вычисления начинается в корневой вершине.
На каждом шаге, переход осуществляется следующим образом. Пусть пометка очередной вершины $v_i$ равна $A$. Это означает, что сейчас Алиса должна применить функцию $g_i(x)$(соответствующую вершине $v_i$) к ее значению $x$. Если результат 0, то она отсылает Бобу значение 0 и переходит по ребру с меткой 0. Аналогично с 1.
Если же пометка $B$, то аналогично действовать должен Боб, применяя функцию $h_j(y)$ к его значению $y$.

Если текущая вершина это лист, то соответствующее ему значение $z \in Z$ объявляется результатом выполнения.
Это отражает идею, что к этому моменту все участники знают этот ответ.

\begin{Def}
Протокол вычисляет функцию $ f \colon X \times Y \rightarrow Z $, \linebreak
если $ \forall x \in X \; \forall y \in Y $ при движении по графу протокола по описанным правилам исполнители попадут в лист, которому соответсвует $z=f(x,y)$.
\end{Def}

\subsection{Детерминированная коммуникационная сложность}

\begin{Def}
Сложностью коммуникационного протокола называется его глубина.
Детерминированной коммуникационной сложностью функции f называется минимальная сложность коммуникационного протокола, вычисляющего f. Обозначается CC(f).
\end{Def}

\begin{Statement}
Для функции $ f \colon X \times Y \rightarrow Z $ справедливы следующие тривиальные оценки:
    \begin{enumerate}
        \item
        $
            CC(f) \leq
            \lceil log|X| \rceil +
            \lceil log|Y| \rceil
        $
        \item
        $
            CC(f) \leq
            \lceil log|X| \rceil +
            \lceil log|Z| \rceil
        $
        \item
        $
            CC(f) \leq
            \lceil log|Y| \rceil +
            \lceil log|Z| \rceil
        $
        \item
        Если f сюръективна, то $ CC(f) \geq \lceil log|Z| \rceil $
    \end{enumerate}
\end{Statement}

Заметим, что в пункте 4 если $Z=\{0,1\}$, то $log_2|Z| = 1$, а значит в случае такого множества этот метод доказательства нижней оценки не эффективен.

\subsection{Одноцветные декартовы прямоугольники}

\begin{Statement}
Пусть $\Pi$ - некоторый коммуникационный протокол, а l - произвольный его лист.
Обозначим через $S_l$ множество таких пар (x, y) $\in X \times Y$,
что на входе (x, y) протокол $\Pi$ остановится в листе l.
Тогда $\exists A \subset X, B \subset Y$ такие что $S_l = A \times B$, а декартов прямоугольник $A \times B$ должен быть одноцветным с точки зрения значения функции f.
\end{Statement}

\begin{Def}
    В силу конечности множеств X и Y можно занумеровать их элементы.
    Тогда коммуникационной матрицей будем называть матрицу $M_f$ размера $|X| \times |Y|$,
    такую что каждый ее элемент $m_{ij} = f(x_i, y_j), x_i \in X, y_j \in Y \; \forall i, j$
\end{Def}

\begin{Def}
    $C^D(f)$ (англ. Disjoint Cover) - минимальное количество одноцветных прямоугольников, на которые можно разбить $X \times Y$.
    А величина $C^P(f)$ - минимально число листьев в протоколе.
\end{Def}

\begin{Statement}
    $$C^D \leq C^P \leq 2^{CC(f)}$$
\end{Statement}

\subsection{Метод трудных множества}
\begin{Def}
    Для функции $ f \colon X \times Y \rightarrow Z $
    множество $S \subset X \times Y$ называется трудным (fooling set),
    если
    \begin{enumerate}
        \item
        $\exists z \in Z \; \forall (x,y) \in X \times Y \; f(x,y)=z$
        \item
        $\forall (x,y)\ne(x',y') \in X \times Y$ выполнено
        $f(x,y') \ne z$ или $f(x',y) \ne z$
    \end{enumerate}
\end{Def}

\begin{Th}
    Пусть K - трудное множество для функции $f \colon X \times Y \rightarrow Z$
    Тогда CC(f) > log(|K|).
\end{Th}


\section{Недетерминированные протоколы}
В недерминированном случае каждое действие не определяется однозначно. Мы считаем, что участники вычислений "угадывают" подсказки $adv_a$ и $adv_b$, что позволяет им действовать эффективнее.
Если подсказка оказалась удачной, то будет получен правильный ответ.
Каковы бы ни была подсказка, участники не могут ошибиться,
воспользовавшись ей: либо они получат верный ответ, либо не получат ответ вообще.

\begin{Def}
Коммуникационным недетерминированным протоколом для вычисления некоторой функции
$ f \colon X \times Y \rightarrow Z $
называется ориентированное двоичное дерево, такое что:
\begin{enumerate}
    \item
    Каждой \textbf{листовой} вершине ставится в соответствие некоторый элемент из Z или ? - неопределенность.
    \item
    Каждая \textbf{внутренняя} вершина помечена значением из $ \{ A, B \} $
    \item
    Для для каждой вершины $v_i$ с пометкой $A$ задана функция \linebreak
    $ g_i \colon X \times Adv_a \rightarrow \{0, 1\} $
    \item
    Для для каждой вершины $v_j$ с пометкой $B$ задана функция \linebreak
    $ h_j \colon Y \times Adv_b \rightarrow \{0, 1\} $
    \item
    Каждому ребру приписано значение из \{0, 1\}, а из каждой вершины, не являющегося листом, исходит ровно одно ребро с пометкой 0 и ровно одно с пометкой 1.
\end{enumerate}
\end{Def}

\begin{Def}
    Недетерминированный протокол P вычисляет функцию
    $ f \colon X \times Y \rightarrow Z $
    если:
    \begin{enumerate}
        \item
        $\forall x \in X \; \forall y \in Y \;
         \exists adv_a \in Adv_a \; \exists adv_b \in Adv_b$
        такие что следуя пути, соответствующему $adv_a$ и $adv_b$
        участники попадут в лист с меткой $f(x,y)$
        \item
        $\forall x \in X \; \forall y \in Y \;
         \forall adv_a \in Adv_a \; \forall adv_b \in Adv_b$
        такие что следуя пути, соответствующему $adv_a$ и $adv_b$
        участники попадут в лист либо с меткой $f(x,y)$ либо с меткой неопределенности ?.
    \end{enumerate}
\end{Def}

\begin{Def}
Сложностью недетерминированного коммуникационного протокола называется его глубина.
Недетерминированной коммуникационной сложностью функции f называется минимальная сложность коммуникационного протокола, вычисляющего f. Обозначается NCC(f).
\end{Def}

Рассмотрим матрицу функции $M_f$. Листьям по-прежнему соответствуют f-одноцветные прямоугольники.
Однако прямоугольники могут пересекаться, так как одна и та же пара (x,y) может приводить в разные листья в зависимости от "советов".
Поэтому необходимо рассмотреть не разбиение $M_f$, а его покрытие.

\begin{Def}
Назовем $cov_z(f)$ минимальное число прямоугольников,
покрывающих все элементы матрицы $M_f$ со значением z
(и никакие другие). Обозначаем cov(f) минимальное число f-одноцветных прямоугольников, покрывающих всю
матрицу $M_f$ ($cov(f) = \sum cov_z(f)$).
\end{Def}

\begin{Statement}
Для любой функции $f \colon X \times Y \rightarrow Z$ выполнено:
\begin{enumerate}
    \item
    $NCC(f) \leq \lceil log(cov(f)) \rceil + 1$
    \item
    $cov(f) \leq 2^{CC(f)}$
\end{enumerate}
\end{Statement}

\begin{Th}
    Для любой функции $f \colon X \times Y \rightarrow Z$
    $$CC(f) = O(NCC(f)^2)$$
\end{Th}
\textbf{Доказательство:}
На самом деле докажем более точное утверждение, а именно
$$ CC(f)=O(log(cov_0(f)) \cdot (log(cov_1(f))+2))$$
Зафиксируем минимальное покрытие одноцветными прямоугольниками $M_f$.
Заметим справедливость следующего утверждения:
\begin{Statement}
    Два комбинаторных прямоугольника $R_0$ и $R_1$ соответствующие цветам 0 и 1 не имеют общих строк или не имеют общих столбцов.
\end{Statement}
Действительно, если бы они имели и общую строку и общий столбец,
то по определению комбинаторного прямоугольника они бы пересекались, что противоречит их одноцветности.
\begin{Statement}
    \textbf{(Следствие)}
    Пусть $R_1$ прямоугольник цвета 1 из покрытия $M_f$.
    $R_0^1...R_0^s$ набор прямоугольников цвета 0 из того же покрытия. Тогда $R_1$ либо не имеет общих строк с
    $k \geq \frac{s}{2}$ прямоугольниками из набора,
    либо не имеет общих столбцов с $k \geq \frac{s}{2}$
    прямоугольниками из данного набора.
\end{Statement}
Детерминированный коммуникационный протокол будет устроен следующим образом.
Он будет построен из нескольких одинакавых шагов.
Изначально имеется $cov_0(f)$
прямоугольников цвета 0 покрывающих все 0.
На каждом шаге Алиса и Боб будут исключать не менее половины из
оставшихся к этому моменту таких прямоугольников.

Шаг будет осуществляться следующим образом. Алиса пытается найти такой
прямоугольник цвета 1, что он пересекает строку x и не имеет общих столбцов не менее чем с половиной оставшихся прямоугольников цвета 0 из покрытия $M_f$.
Если Алисе это удается, то она сообщает номер прямоугольника Бобу.
После этого они оба исключают из дальнейшего рассмотрения все
прямоугольники цвета 0, не пересекающиеся по столбцам с указанным прямоугольником. Затем они переходят к следующему шагу.
Иначе, если Алиса не нашла такого прямоугольника цвета 1, то она сообщает об этом Бобу.
Боб в свою очередь аналогично пытается  найти такой прямоугольник цвета 1, такой что он пересекает столбец y и не имеет общих строк не менее чем с половиной оставшихся прямоугольников цвета 0.
Если ему это удалось, то он сообщает Алисе номер прямоугольника и совершенно аналогичным образом они исключают из дальнейшего рассмотрения все прямоугольники цвета 0, не пересекающиеся по столбцам с указанным прямоугольником. Затем они переходят к следующему шагу.

Протокол завершается, если выполнено одно из двух условий. Первое, если все прямоугольники цвета 0 были исключены в процессе работы. В этом случае ответ 1. Второе, на некотором шаге ни Алиса, ни Боб не смогли найти искомое ими множество цвета 1. В это случае ответ 0.


Покажем корректность протокола. Если $f(x, y)=0$, то пара (x,y) должна быть покрыта хотя бы одним прямоугольников цвета 0.
Согласно описанию протокола, такой прямоугольник не может быть удален ни на каком шаге.
Следовательно, если протокол получил ответ 1, то это не может быть ошибкой.
Пусть теперь $f(x, y)=1$. Тогда пара (x,y) должна быть покрыта хотя бы одним прямоугольником цвета 1.
По следствию, либо Алиса, либо Боб могут отсечь хотя бы половину прямоугольников цвета 0, не исключенных ранее(хотя бы один такой существует, не обязательно единственный).
Значит если протокол завершился с ответом 0, то ошибки быть не может.
Из этих двух случаев следует корректность протокола.


Оценим коммуникационную сложность протокола.
Число шагов не превосходит $\lceil log(cov_0(f)) \rceil$,
так как на каждом шаге число прямоугольников уменьшается как минимум вдвое, а изначально их $cov_0(f)$.
Каждая итерация в свою очередь требует передачи номера прямоугольника и двух дополнительных битов(сообщающих об успехе/неудаче Алисы или Боба соответственно).
В итоге получается коммуникационная сложность
$$ CC(f)=O(log(cov_0(f)) \cdot (log(cov_1(f))+2))
= O(log^2(cov(f))) = O(NCC(f)^2)$$


\section{Вероятностные протоколы}
В вероятностном случае Алиса и Боб независимо выбирают последовательность из равномерно распределенных случайных битов
$r_a=\{0, 1\}^{l_a}$ и $r_b=\{0, 1\}^{l_b}$ соответственно. Для каждой пары аргументов $(x,y)$ появляется вероятность попасть в каждый из листов. Соответственно также появляется возможность получить неправильный ответ, однако в отличие от недетерминированного случая ответ обязательно будет получен.

\begin{Def}
Для каждого вероятностного протокола и входа $(x,y)$ введем функцию вероятности ошибки протокола на заданном входе $\varepsilon(x,y)$.
\end{Def}

\begin{Def}
Для $\varepsilon>0$ вероятностной коммуникационной сложностью
$RCC_{\varepsilon}(f)$ назовем
минимальную глубину вероятностного протокола, вероятность ошибки которого не превосходит $\varepsilon$.
\end{Def}

\begin{Def}
Средней коммуникационной сложностью вероятностного протокола для фиксированных $(x, y)$ назовем математическое ожидание числа пересылаемых битов.
\end{Def}

\begin{Def}
Вероятностной коммуникационной сложностью с нулевой ошибкой
$RCC_0(f)$ называется наилучшая средняя коммуникационная сложность
вероятностных протоколов с нулевой ошибкой.
\end{Def}

\begin{Statement}
    Для любой функции $f \colon X \times Y \rightarrow Z$
    $$NCC(f) \leq RCC_0$$
\end{Statement}

\section{Классы коммуникационной сложности}
\begin{Def}
    $P^{CC} = \{f \; | \; \exists k $ СС(f) $\leq log^k(n)\}$
\end{Def}

\begin{Def}
    $NP^{CC} = \{f \; | \; \exists k$ NСС(f) $\leq log^k(n)\}$
\end{Def}

\end{document}

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[russian]{babel}
\usepackage{xcolor}

\begin{document}
\tableofcontents
\newpage

\section{Детерминированные протоколы}
\subsection{Модель вычислений и основные определения}


\newtheorem{Def}{Определение}
\newtheorem{Statement}{Утверждение}
\newtheorem{Th}{Теорема}

Будем рассматривать следующую задачу.
Есть два участника процесса(два человека или два компьютера), которые должны совместно вычислить значение функции
$ f \colon X \times Y \rightarrow Z $, где $X, Y, Z$ некоторые конечные множества.
В качестве $Z$ обычно будем рассматривать множество значений бита \{0, 1\}.
Традиционно этих участников называют Алиса и Боб,
поэтому для удобства и соответствия литературе будем называть их так же.
Сложность их задачи состоит в том, что аргумент, на котором необходимо посчитать значение функции, разделен на две части:
у Алисы есть только $x \in X$, а у Боба только $y \in Y$.

Однако в их распоряжении есть некий абстрактный канал связи, через который они могут передавать друг другу данные. Передача по этому каналу связи может быть дорогой(или занимать значительное время), поэтому необходимо минимизировать количество битов, передаваемых в процессе вычисления функции.

Так же предполагается, что Алиса и Боб заранее знают функцию $f$ и договариваются о протоколе -
наборе соглашений о том, как и в каком порядке будет происходить обмен информацией. В коммуникационной сложности учитывается только количество передаваемых битов, а время вычислений у каждого участника игнорируется.

\begin{Def}
Коммуникационным протоколом для вычисления некоторой функции
$ f \colon X \times Y \rightarrow Z $
называется ориентированное двоичное дерево, такое что:
\begin{enumerate}
    \item
    Каждой \textbf{листовой} вершине ставится в соответствие некоторый элемент из Z.
    \item
    Каждая \textbf{внутренняя} вершина помечена значением из $ \{ A, B \} $
    \item
    Для для каждой вершины $v_i$ с пометкой $A$ задана функция \linebreak
    $ g_i \colon X \rightarrow \{0, 1\} $
    \item
    Для для каждой вершины $v_j$ с пометкой $B$ задана функция \linebreak
    $ h_j \colon Y \rightarrow \{0, 1\} $
    \item
    Каждому ребру приписано значение из \{0, 1\}, а из каждой вершины, не являющегося листом, исходит ровно одно ребро с пометкой 0 и ровно одно с пометкой 1.
\end{enumerate}
\end{Def}

Выполнение протокола участниками вычисления начинается в корневой вершине.
На каждом шаге, переход осуществляется следующим образом. Пусть пометка очередной вершины $v_i$ равна $A$. Это означает, что сейчас Алиса должна применить функцию $g_i(x)$(соответствующую вершине $v_i$) к ее значению $x$. Если результат 0, то она отсылает Бобу значение 0 и переходит по ребру с меткой 0. Аналогично с 1.
Если же пометка $B$, то аналогично действовать должен Боб, применяя функцию $h_j(y)$ к его значению $y$.

Если текущая вершина это лист, то соответствующее ему значение $z \in Z$ объявляется результатом выполнения.
Это отражает идею, что к этому моменту все участники знают этот ответ.

\begin{Def}
Протокол вычисляет функцию $ f \colon X \times Y \rightarrow Z $, \linebreak
если $ \forall x \in X \; \forall y \in Y $ при движении по графу протокола по описанным правилам исполнители попадут в лист, которому соответсвует $z=f(x,y)$.
\end{Def}

\subsection{Детерминированная коммуникационная сложность}

\begin{Def}
Сложностью коммуникационного протокола называется его глубина.
Детерминированной коммуникационной сложностью функции f называется минимальная сложность коммуникационного протокола, вычисляющего f. Обозначается CC(f).
\end{Def}

\begin{Statement}
Для функции $ f \colon X \times Y \rightarrow Z $ справедливы следующие тривиальные оценки:
    \begin{enumerate}
        \item
        $
            CC(f) \leq
            \lceil log|X| \rceil +
            \lceil log|Y| \rceil
        $
        \item
        $
            CC(f) \leq
            \lceil log|X| \rceil +
            \lceil log|Z| \rceil
        $
        \item
        $
            CC(f) \leq
            \lceil log|Y| \rceil +
            \lceil log|Z| \rceil
        $
        \item
        Если f сюръективна, то $ CC(f) \geq \lceil log|Z| \rceil $
    \end{enumerate}
\end{Statement}

Заметим, что в пункте 4 если $Z=\{0,1\}$, то $log_2|Z| = 1$, а значит в случае такого множества этот метод доказательства нижней оценки не эффективен.

\subsection{Одноцветные декартовы прямоугольники}

\begin{Statement}
Пусть $\Pi$ - некоторый коммуникационный протокол, а l - произвольный его лист.
Обозначим через $S_l$ множество таких пар (x, y) $\in X \times Y$,
что на входе (x, y) протокол $\Pi$ остановится в листе l.
Тогда $\exists A \subset X, B \subset Y$ такие что $S_l = A \times B$, а декартов прямоугольник $A \times B$ должен быть одноцветным с точки зрения значения функции f.
\end{Statement}

\begin{Def}
    В силу конечности множеств X и Y можно занумеровать их элементы.
    Тогда коммуникационной матрицей будем называть матрицу $M_f$ размера $|X| \times |Y|$,
    такую что каждый ее элемент $m_{ij} = f(x_i, y_j), x_i \in X, y_j \in Y \; \forall i, j$
\end{Def}

\begin{Def}
    $C^D(f)$ (англ. Disjoint Cover) - минимальное количество одноцветных прямоугольников, на которые можно разбить $X \times Y$.
    А величина $C^P(f)$ - минимально число листьев в протоколе.
\end{Def}

\begin{Statement}
    $$C^D \leq C^P \leq 2^{CC(f)}$$
\end{Statement}

\subsection{Метод трудных множества}
\begin{Def}
    Для функции $ f \colon X \times Y \rightarrow Z $
    множество $S \subset X \times Y$ называется трудным (fooling set),
    если
    \begin{enumerate}
        \item
        $\exists z \in Z \; \forall (x,y) \in X \times Y \; f(x,y)=z$
        \item
        $\forall (x,y)\ne(x',y') \in X \times Y$ выполнено
        $f(x,y') \ne z$ или $f(x',y) \ne z$
    \end{enumerate}
\end{Def}

\begin{Th}
    Пусть K - трудное множество для функции $f \colon X \times Y \rightarrow Z$
    Тогда CC(f) > log(|K|).
\end{Th}


\section{Недетерминированные протоколы}
В недерминированном случае каждое действие не определяется однозначно. Мы считаем, что участники вычислений "угадывают" подсказки $adv_a$ и $adv_b$, что позволяет им действовать эффективнее.
Если подсказка оказалась удачной, то будет получен правильный ответ.
Каковы бы ни была подсказка, участники не могут ошибиться,
воспользовавшись ей: либо они получат верный ответ, либо не получат ответ вообще.

\begin{Def}
Коммуникационным недетерминированным протоколом для вычисления некоторой функции
$ f \colon X \times Y \rightarrow Z $
называется ориентированное двоичное дерево, такое что:
\begin{enumerate}
    \item
    Каждой \textbf{листовой} вершине ставится в соответствие некоторый элемент из Z или ? - неопределенность.
    \item
    Каждая \textbf{внутренняя} вершина помечена значением из $ \{ A, B \} $
    \item
    Для для каждой вершины $v_i$ с пометкой $A$ задана функция \linebreak
    $ g_i \colon X \times Adv_a \rightarrow \{0, 1\} $
    \item
    Для для каждой вершины $v_j$ с пометкой $B$ задана функция \linebreak
    $ h_j \colon Y \times Adv_b \rightarrow \{0, 1\} $
    \item
    Каждому ребру приписано значение из \{0, 1\}, а из каждой вершины, не являющегося листом, исходит ровно одно ребро с пометкой 0 и ровно одно с пометкой 1.
\end{enumerate}
\end{Def}

\begin{Def}
    Недетерминированный протокол P вычисляет функцию
    $ f \colon X \times Y \rightarrow Z $
    если:
    \begin{enumerate}
        \item
        $\forall x \in X \; \forall y \in Y \;
         \exists adv_a \in Adv_a \; \exists adv_b \in Adv_b$
        такие что следуя пути, соответствующему $adv_a$ и $adv_b$
        участники попадут в лист с меткой $f(x,y)$
        \item
        $\forall x \in X \; \forall y \in Y \;
         \forall adv_a \in Adv_a \; \forall adv_b \in Adv_b$
        такие что следуя пути, соответствующему $adv_a$ и $adv_b$
        участники попадут в лист либо с меткой $f(x,y)$ либо с меткой неопределенности ?.
    \end{enumerate}
\end{Def}

\begin{Def}
Сложностью недетерминированного коммуникационного протокола называется его глубина.
Недетерминированной коммуникационной сложностью функции f называется минимальная сложность коммуникационного протокола, вычисляющего f. Обозначается NCC(f).
\end{Def}

Рассмотрим матрицу функции $M_f$. Листьям по-прежнему соответствуют f-одноцветные прямоугольники.
Однако прямоугольники могут пересекаться, так как одна и та же пара (x,y) может приводить в разные листья в зависимости от "советов".
Поэтому необходимо рассмотреть не разбиение $M_f$, а его покрытие.

\begin{Def}
Назовем $cov_z(f)$ минимальное число прямоугольников,
покрывающих все элементы матрицы $M_f$ со значением z
(и никакие другие). Обозначаем cov(f) минимальное число f-одноцветных прямоугольников, покрывающих всю
матрицу $M_f$ ($cov(f) = \sum cov_z(f)$).
\end{Def}

\begin{Statement}
Для любой функции $f \colon X \times Y \rightarrow Z$ выполнено:
\begin{enumerate}
    \item
    $NCC(f) \leq \lceil log(cov(f)) \rceil + 1$
    \item
    $cov(f) \leq 2^{CC(f)}$
\end{enumerate}
\end{Statement}

\begin{Th}
    Для любой функции $f \colon X \times Y \rightarrow Z$
    $$CC(f) = O(NCC(f)^2)$$
\end{Th}
\textcolor{red}{Доказательство тут будет}

\section{Вероятностные протоколы}
В вероятностном случае Алиса и Боб независимо выбирают последовательность из равномерно распределенных случайных битов
$r_a=\{0, 1\}^{l_a}$ и $r_b=\{0, 1\}^{l_b}$ соответственно. Для каждой пары аргументов $(x,y)$ появляется вероятность попасть в каждый из листов. Соответственно также появляется возможность получить неправильный ответ, однако в отличие от недетерминированного случая ответ обязательно будет получен.

\begin{Def}
Для каждого вероятностного протокола и входа $(x,y)$ введем функцию вероятности ошибки протокола на заданном входе $\varepsilon(x,y)$.
\end{Def}

\begin{Def}
Для $\varepsilon>0$ вероятностной коммуникационной сложностью
$RCC_{\varepsilon}(f)$ назовем
минимальную глубину вероятностного протокола, вероятность ошибки которого не превосходит $\varepsilon$.
\end{Def}

\begin{Def}
Средней коммуникационной сложностью вероятностного протокола для фиксированных $(x, y)$ назовем математическое ожидание числа пересылаемых битов.
\end{Def}

\begin{Def}
Вероятностной коммуникационной сложностью с нулевой ошибкой
$RCC_0(f)$ называется наилучшая средняя коммуникационная сложность
вероятностных протоколов с нулевой ошибкой.
\end{Def}

\begin{Statement}
    Для любой функции $f \colon X \times Y \rightarrow Z$
    $$NCC(f) \leq RCC_0$$
\end{Statement}

\section{Классы коммуникационной сложности}
\begin{Def}
    $P^{CC} = \{f \; | \; \exists k \; СС(f) \leq log^k(n)\}$
\end{Def}

\begin{Def}
    $NP^{CC} = \{f \; | \; \exists k \; NСС(f) \leq log^k(n)\}$
\end{Def}

\end{document}
